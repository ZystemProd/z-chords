<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chord Viewer – Piano Notes Highlighter</title>
    <style>
        :root {
            --bg: #0b0f15;
            --card: #12141a;
            --white: #fff;
            --black: #0b0b0b;
            --pressed-red-1: #ff6565;
            --pressed-red-2: #d92b2b;
            --root-green-1: #2ecc71;
            --root-green-2: #27ae60;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: Inter, system-ui, Arial;
            background: var(--bg);
            color: #e6eef8
        }

        .app {
            max-width: 1100px;
            margin: 28px auto;
            padding: 20px
        }

        header {
            text-align: center;
            margin-bottom: 14px
        }

        h1 {
            margin: 0;
            font-size: 20px
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--card);
            padding: 14px;
            border-radius: 12px;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }

        .controls-left {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .controls-right {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        input[type=text] {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #242832;
            background: #0f1621;
            color: #e6eef8
        }

        button,
        select {
            background: #1e6ef0;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer
        }

        .boards {
            display: grid;
            gap: 16px
        }

        .card {
            background: linear-gradient(180deg, #0f1621, #0b1116);
            border-radius: 12px;
            padding: 14px;
            border: 1px solid rgba(255, 255, 255, 0.03);
            position: relative
        }

        .card h3 {
            margin: 0 0 8px;
            font-size: 16px;
            font-weight: bold
        }

        .note-list {
            color: #9fb0c2;
            font-size: 13px;
            margin-bottom: 10px
        }

        .inversion-control {
            position: absolute;
            top: 14px;
            right: 14px
        }

        /* Piano layout */
        .piano {
            position: relative;
            width: 100%;
            height: 210px;
            background: linear-gradient(180deg, #071022, #091220);
            border-radius: 8px;
            padding: 18px;
        }

        .white-keys {
            display: grid;
            grid-template-columns: repeat(auto-fill, 50px);
            height: 100%;
            gap: 4;
            position: relative;
        }

        .white-key {
            position: relative;
            background: var(--white);
            border: 1px solid #000000;
            border-right: none;
            border-radius: 0 0 8px 8px;
            box-shadow: inset 0 -6px 0 rgba(0, 0, 0, 0.06);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 8px;
            box-sizing: border-box;
        }

        .white-key:last-child {
            border-right: 1px solid #cfcfcf;
        }

        .white-key.pressed {
            background: linear-gradient(180deg, var(--pressed-red-1), var(--pressed-red-2));
            color: #fff;
            font-weight: bold;
        }

        .white-key.root {
            background: linear-gradient(180deg, var(--root-green-1), var(--root-green-2));
            color: #fff;
        }

        .white-key .label {
            font-size: 12px;
            color: #22313a;
            font-weight: bold
        }

        .black-key {
            position: absolute;
            width: 28px;
            height: 45%;
            top: 18px;
            background: var(--black);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.6);
            border: 2px solid #000;
            z-index: 5;
        }

        .black-key.pressed {
            background: linear-gradient(180deg, #d94b4b, #b21616);
        }

        .black-key.root {
            background: linear-gradient(180deg, var(--root-green-1), var(--root-green-2));
        }

        .kbd-labels {
            display: flex;
            justify-content: space-between;
            color: #9fb0c2;
            margin-top: 8px;
            font-size: 12px
        }

        .interval {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #fff;
            font-weight: bold;
            pointer-events: none;
        }


        @media (max-width:700px) {
            .piano {
                height: 160px
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <h1>Chord Viewer</h1>
            <div style="color:#9fb0c2;font-size:13px;margin-top:6px">Type a chord (e.g. C, Dm, Bbmaj7, G7) and click
                Add. You can switch inversion per chord.</div>
        </header>

        <section class="controls">
            <div class="controls-left">
                <input id="chordInput" type="text" placeholder="e.g. C, Dm, Bbmaj7, F#7" list="suggestions"
                    autocomplete="off" />
                <datalist id="suggestions"></datalist>
                <button id="addChord">Add chord</button>
                <button id="clearAll">Clear</button>
            </div>

            <div class="controls-right">
                <span style="color:#9fb0c2;font-size:13px;">Transpose by:</span>
                <button id="transposeDown">–1</button>
                <button id="transposeUp">+1</button>
            </div>
        </section>

        <section class="boards" id="boards"></section>
    </div>

    <script>
        const N_SHARP = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const ENHARMONIC = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };
        const CHORD_PATTERNS = {
            '': [0, 4, 7], 'm': [0, 3, 7], 'dim': [0, 3, 6], 'aug': [0, 4, 8],
            'sus2': [0, 2, 7], 'sus4': [0, 5, 7], '6': [0, 4, 7, 9], 'm6': [0, 3, 7, 9], '7': [0, 4, 7, 10],
            'maj7': [0, 4, 7, 11], 'm7': [0, 3, 7, 10], 'dim7': [0, 3, 6, 9], 'm7b5': [0, 3, 6, 10],
            'add9': [0, 4, 7, 14], '9': [0, 4, 7, 10, 14], 'm9': [0, 3, 7, 10, 14], 'maj9': [0, 4, 7, 11, 14]
        };
        const CHORD_TYPES = Object.keys(CHORD_PATTERNS).filter(k => k !== '');
        const typesSorted = CHORD_TYPES.slice().sort((a, b) => b.length - a.length);
        const TYPE_RE = typesSorted.join('|');
        const CHORD_RE = new RegExp('^[ ]*([A-Ga-g])([#b]?)(?:(' + TYPE_RE + '))?[ ]*$');

        function normalizeRoot(r) { if (!r) return r; r = r.split(' ').join(''); return r[0].toUpperCase() + (r[1] || ''); }
        function nameToIndex(name) { if (!name) return -1; if (ENHARMONIC[name]) name = ENHARMONIC[name]; return N_SHARP.indexOf(name); }
        function parseChordSymbol(sym) { const m = sym.match(CHORD_RE); if (!m) return null; return { root: normalizeRoot(m[1].toUpperCase() + (m[2] || '')), quality: (m[3] || '') }; }
        function buildChordNotes(rootName, quality, inversion = 0, octave = false) {
            const rootIdx = nameToIndex(rootName);
            if (rootIdx < 0) return null;
            const pattern = CHORD_PATTERNS[quality === undefined ? '' : quality];
            if (!pattern) return null;

            const baseMidi = 60;
            const rootMidi = baseMidi + rootIdx;
            let midiNotes = pattern.map(interval => rootMidi + interval);

            // Apply inversion
            for (let i = 0; i < inversion; i++) {
                midiNotes[0] += 12;
                midiNotes.push(midiNotes.shift());
            }

            // Apply octave shift
            if (octave) {
                midiNotes = midiNotes.map(m => m + 12);
            }

            midiNotes.sort((a, b) => a - b);

            return { notes: midiNotes, rootMidi: rootMidi }; // Return rootMidi separately
        }



        const boardsEl = document.getElementById('boards');

        function makePiano(chord) {
            const midiNotes = chord.notes;
            const rootMidi = chord.rootMidi; // always the original root
            const LOW = 60, HIGH = 83;

            // Map intervals relative to original root
            const intervals = midiNotes.map(m => {
                const interval = (m - rootMidi + 12) % 12;
                switch (interval) {
                    case 0: return 'R';
                    case 3: return 'm3';
                    case 4: return '3';
                    case 5: return '4';
                    case 6: return 'b5';
                    case 7: return '5';
                    case 8: return '6';
                    case 9: return '6/13';
                    case 10: return '7';
                    case 11: return 'maj7';
                    case 14: return '9';
                    default: return '';
                }
            });

            const whiteMIDIs = [];
            for (let m = LOW; m <= HIGH; m++) { if (!N_SHARP[m % 12].includes('#')) whiteMIDIs.push(m); }

            const pianoWrap = document.createElement('div');
            pianoWrap.className = 'piano';

            const whiteGrid = document.createElement('div');
            whiteGrid.className = 'white-keys';

            whiteMIDIs.forEach(midi => {
                const wk = document.createElement('div');
                wk.className = 'white-key';
                wk.dataset.midi = midi;

                // Highlight only the original root
                if (midi === rootMidi) wk.classList.add('root');

                const nm = N_SHARP[midi % 12];
                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = nm.replace('#', '♯');
                wk.appendChild(label);

                const idx = midiNotes.indexOf(midi);
                if (idx >= 0) {
                    const interval = document.createElement('div');
                    interval.className = 'interval';
                    interval.textContent = intervals[idx];
                    wk.appendChild(interval);
                    wk.classList.add('pressed');
                }

                whiteGrid.appendChild(wk);
            });

            pianoWrap.appendChild(whiteGrid);

            requestAnimationFrame(() => {
                const whiteEls = whiteGrid.querySelectorAll('.white-key');
                whiteEls.forEach((wk) => {
                    const midi = parseInt(wk.dataset.midi);
                    const note = N_SHARP[midi % 12];
                    if (note === 'E' || note === 'B') return;

                    const blackMidi = midi + 1;
                    const bk = document.createElement('div');
                    bk.className = 'black-key';
                    bk.dataset.midi = blackMidi;

                    const whiteWidthPx = wk.offsetWidth;
                    const blackWidthPx = bk.offsetWidth;
                    const leftPx = wk.offsetLeft + whiteWidthPx - (blackWidthPx / 2 + -4);
                    bk.style.left = leftPx + 'px';

                    // Highlight only the original root
                    if (blackMidi === rootMidi) bk.classList.add('root');

                    const idx = midiNotes.indexOf(blackMidi);
                    if (idx >= 0) {
                        const interval = document.createElement('div');
                        interval.className = 'interval';
                        interval.textContent = intervals[idx];
                        bk.appendChild(interval);
                        bk.classList.add('pressed');
                    }

                    pianoWrap.appendChild(bk);
                });
            });

            return pianoWrap;
        }




        function getName(midi) { const note = N_SHARP[midi % 12]; const octave = Math.floor(midi / 12) - 1; return note.replace('#', '♯') + octave; }

        function render() {
            boardsEl.innerHTML = '';
            const chords = boardsEl.dataset.chordsList ? JSON.parse(boardsEl.dataset.chordsList) : [];
            if (!chords.length) {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = '<h3>No chords added</h3><div class="note-list">Type a chord above and click "Add chord".</div>';
                boardsEl.appendChild(card);
                return;
            }

            chords.forEach(({ sym, inversion, octave }) => {
                const parsed = parseChordSymbol(sym);
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = '<h3>' + sym + '</h3>';
                if (!parsed) {
                    card.innerHTML += '<div class="note-list">Unrecognized chord symbol.</div>';
                    boardsEl.appendChild(card);
                    return;
                }

                // Build chord notes with root info
                const chordData = buildChordNotes(parsed.root, parsed.quality, inversion, chords.find(c => c.sym === sym).octave);
                if (!chordData || !chordData.notes.length) {
                    card.innerHTML += '<div class="note-list">Unsupported chord quality.</div>';
                    boardsEl.appendChild(card);
                    return;
                }

                // Extract notes
                const midiNotes = chordData.notes;

                // Display note names
                const noteNames = midiNotes.map(m => getName(m)).join(' · ');
                let labelText = 'Notes (inversion ' + inversion + ')';
                if (chords.find(c => c.sym === sym).octave) labelText += ', Octave +1';
                card.innerHTML += '<div class="note-list">' + labelText + ': ' + noteNames + '</div>';

                // Create piano with proper root & intervals
                const piano = makePiano(chordData);
                card.appendChild(piano);


                const invCtrl = document.createElement('select');
                invCtrl.className = 'inversion-control';
                const maxInv = Math.max(0, midiNotes.length - 1);
                for (let i = 0; i <= maxInv; i++) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = 'Inv ' + i;
                    if (!octave && i === inversion) opt.selected = true;
                    invCtrl.appendChild(opt);
                }

                const octaveOpt = document.createElement('option');
                octaveOpt.value = 'octave';
                octaveOpt.text = 'Octave +1';
                if (octave) octaveOpt.selected = true;
                invCtrl.appendChild(octaveOpt);

                invCtrl.addEventListener('change', () => {
                    const selected = invCtrl.value;
                    const chord = chords.find(c => c.sym === sym);
                    if (selected === 'octave') {
                        chord.octave = true;
                        chord.inversion = 0;
                    } else {
                        chord.inversion = parseInt(selected);
                        chord.octave = false;
                    }
                    boardsEl.dataset.chordsList = JSON.stringify(chords);
                    render();
                });

                card.appendChild(invCtrl);
                boardsEl.appendChild(card);
            });
        }

        function addChordToList(sym) {
            if (!sym) return;
            const parsed = parseChordSymbol(sym);
            if (!parsed) return;
            const list = boardsEl.dataset.chordsList ? JSON.parse(boardsEl.dataset.chordsList) : [];
            list.push({ sym: sym.trim(), inversion: 0 });
            boardsEl.dataset.chordsList = JSON.stringify(list);
            render();
        }

        function addChordsFromInput(inputValue) {
            if (!inputValue) return;
            const chords = inputValue.split(',').map(c => c.trim()).filter(c => c);
            chords.forEach(c => addChordToList(c));
        }

        const chordInput = document.getElementById('chordInput');
        const suggestionsEl = document.getElementById('suggestions');

        chordInput.addEventListener('input', () => {
            const val = chordInput.value.trim().toUpperCase();
            suggestionsEl.innerHTML = '';
            if (!val) return;

            const matches = [];
            N_SHARP.forEach(note => {
                CHORD_TYPES.forEach(type => {
                    const chord = note + type;
                    if (chord.toUpperCase().startsWith(val)) matches.push(chord);
                });
            });

            matches.slice(0, 10).forEach(chord => {
                const option = document.createElement('option');
                option.value = chord;
                suggestionsEl.appendChild(option);
            });

            const exactMatch = matches.find(ch => ch.toUpperCase() === val);
            if (exactMatch) {
                addChordsFromInput(exactMatch);
                chordInput.value = '';
                suggestionsEl.innerHTML = '';
            }
        });

        function transposeChords(amount) {
            const chords = boardsEl.dataset.chordsList ? JSON.parse(boardsEl.dataset.chordsList) : [];
            chords.forEach(ch => {
                const parsed = parseChordSymbol(ch.sym);
                if (!parsed) return;

                let rootIdx = nameToIndex(parsed.root);
                if (rootIdx < 0) return;

                rootIdx = (rootIdx + amount + 12) % 12;
                const newRoot = N_SHARP[rootIdx];
                ch.sym = newRoot + (parsed.quality || '');
            });
            boardsEl.dataset.chordsList = JSON.stringify(chords);
            render();
        }

        document.getElementById('transposeUp').addEventListener('click', () => transposeChords(1));
        document.getElementById('transposeDown').addEventListener('click', () => transposeChords(-1));

        chordInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                addChordsFromInput(chordInput.value);
                chordInput.value = '';
                suggestionsEl.innerHTML = '';
            }
        });

        document.getElementById('addChord').addEventListener('click', () => {
            addChordsFromInput(chordInput.value);
            chordInput.value = '';
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            boardsEl.dataset.chordsList = JSON.stringify([]);
            render();
        });

        render();
    </script>
</body>

</html>